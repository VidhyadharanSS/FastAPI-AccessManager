This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-03T12:23:19.375Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
db.py
main.py
model.py
schemas.py

================================================================
Files
================================================================

================
File: db.py
================
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
#db initialisation
DATABASE_URL = 'sqlite:///./employee.db'

#engine creation
engine = create_engine(DATABASE_URL, connect_args = {'check_same_thread' : False})

#session creation
sessionLocal = sessionmaker(autocommit = False, autoflush = False, bind = engine)

#declarative base mapping
Base = declarative_base()

#dependency injection
def get_db():
    db = sessionLocal()
    try:
        yield db
    finally:
        db.close()

================
File: main.py
================
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from sqlalchemy.ext.declarative import declarative_base
#db initialisation
DATABASE_URL = 'sqlite:///./employee.db'

#engine creation
engine = create_engine(DATABASE_URL, connect_args = {'check_same_thread' : False})

#session creation
sessionLocal = sessionmaker(autocommit = False, autoflush = False, bind = engine)

#declarative base mapping
Base = declarative_base()

#dependency injection
def get_db():
    db = sessionLocal()
    try:
        yield db
    finally:
        db.close()

# ----------------------------------------

# ================================
# File: main.py
# ================================
from fastapi import FastAPI, Depends, HTTPException
from typing import List

from sqlalchemy.orm import Session, joinedload
from passlib.hash import bcrypt # Import bcrypt for password hashing

from db import engine, get_db
import model
import schemas

model.Base.metadata.create_all(bind=engine)

app = FastAPI(title="QuickML Projects", version="0.1.0")

#Create user
@app.post('/users/', response_model = schemas.User, status_code = 201) # Corrected endpoint path
def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):
    hashed_password = bcrypt.hash(user.password) # Hash the password
    db_user = model.User(username = user.username, hashed_password = hashed_password) # Use hashed_password
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

# Employee Endpoints
@app.post("/employees/", response_model=schemas.Employee, status_code=201)
def create_employee(employee: schemas.EmployeeCreate, db: Session = Depends(get_db)):
    hashed_password = bcrypt.hash(employee.user.password) # Hash the password from nested UserCreate
    db_user = model.User(username=employee.user.username, hashed_password=hashed_password) # Create User
    db.add(db_user)
    db.commit()
    db.refresh(db_user)

    db_employee = model.Employee(name=employee.name, email=employee.email, user_id=db_user.id) # Associate Employee with User
    db.add(db_employee)
    db.commit()
    db.refresh(db_employee)
    return db_employee

@app.get("/employees/", response_model=List[schemas.Employee])
def read_employees(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):
    employees = db.query(model.Employee).options(joinedload(model.Employee.user)).offset(skip).limit(limit).all() # Load user relationship
    return employees

@app.get("/employees/{employee_id}", response_model=schemas.Employee)
def read_employee(employee_id: int, db: Session = Depends(get_db)):
    db_employee = db.query(model.Employee).filter(model.Employee.id == employee_id).options(joinedload(model.Employee.projects), joinedload(model.Employee.user)).first() # Load projects and user
    if db_employee is None:
        raise HTTPException(status_code=404, detail="Employee not found")
    return db_employee

@app.put("/employees/{employee_id}", response_model=schemas.Employee)
def update_employee(employee_id: int, employee_in: schemas.EmployeeUpdate, db: Session = Depends(get_db)):
    db_employee = db.query(model.Employee).filter(model.Employee.id == employee_id).first()
    if db_employee is None:
        raise HTTPException(status_code=404, detail="Employee not found")
    employee_data = employee_in.dict(exclude_unset=True)
    for key, value in employee_data.items():
        setattr(db_employee, key, value)
    db.add(db_employee)
    db.commit()
    db.refresh(db_employee)
    return db_employee

@app.delete("/employees/{employee_id}", status_code=204)
def delete_employee(employee_id: int, db: Session = Depends(get_db)):
    db_employee = db.query(model.Employee).filter(model.Employee.id == employee_id).first()
    if db_employee is None:
        raise HTTPException(status_code=404, detail="Employee not found")
    db.delete(db_employee)
    db.commit()
    return {"ok": True}

#Create projects for employees
@app.post('/projects', response_model = schemas.Project, status_code = 201)
def create_project(project: schemas.ProjectCreate, db: Session = Depends(get_db)):
    db_project = model.Project(**project.dict())
    db.add(db_project)
    db.commit()
    db.refresh(db_project)
    return(db_project)

#get all projects for employees
@app.get('/projects/', response_model = List[schemas.Project])
def get_projects(skip: int = 0, limit: int = 100, db:Session = Depends(get_db)):
    projects = db.query(model.Project).offset(skip).limit(limit).all()
    return projects

#get projects  by id
@app.get('/projects/{project_id}', response_model = schemas.Project)
def get_project_by_id(project_id: int, db:Session = Depends(get_db)):
    project = db.query(model.Project).filter(model.Project.id == project_id).options(joinedload(model.Project.employees)).first() # Load employees
    if project is None:
        raise HTTPException(status_code=404, detail="Project not found")
    return project

#update projects by id
@app.put('/projects/{project_id}', response_model = schemas.Project)
def update_project(project_id: int, project_in:schemas.ProjectUpdate, db: Session = Depends(get_db)):
    db_project = db.query(model.Project).filter(model.Project.id == project_id).first()
    if db_project is None:
        raise HTTPException(status_code=404, detail="Project not found")
    project_data = project_in.dict(exclude_unset = True)
    for key,value in project_data.items():
        setattr(db_project, key, value)
    db.add(db_project)
    db.commit()
    db.refresh(db_project)
    return project

#delete projects by id
@app.delete('/projects/{project_id}', response_model = schemas.Project)
def delete_project(project_id: int, db: Session = Depends(get_db)):
    db_project = db.query(model.Project).filter(model.Project.id == project_id).first()
    if db_project is None:
        raise HTTPException(status_code=404, detail="Project not found")
    db.delete(db_project)
    db.commit()
    db.refresh(db_project)
    return project

#assign a employee to a particular project
@app.post('/employees/{employee_id}/projects/{project_id}', response_model = schemas.Employee)
def assign_employee_to_project(employee_id: int, project_id: int, db:Session = Depends(get_db)):
    db_employee = db.query(model.Employee).filter(model.Employee.id == employee_id).first()
    db_project = db.query(model.Project).filter(model.Project.id == project_id).first()

    if db_employee is None:
        raise HTTPException(status_code=404, detail="Employee not found")
    if db_project is None:
        raise HTTPException(status_code=404, detail="Project not found")

    db_employee.projects.append(db_project)

    db.commit()
    db.refresh(db_employee)
    return db_employee

================
File: model.py
================
from sqlalchemy import Column, Integer, String, Boolean, ForeignKey, Table
from sqlalchemy.orm import relationship
from db import Base
from passlib.hash import bcrypt

class User(Base):
    __tablename__ = 'users' # Corrected typo: __tablename__

    id = Column(Integer, primary_key = True, index = True)
    username = Column(String, unique= True, index = True)

    hashed_password = Column(String) # Changed from password_hash for consistency

    is_active = Column(Boolean, default = True)
    is_superuser = Column(Boolean, default = False)

    employees = relationship('Employee', back_populates = 'user') # Corrected relationship name

    def verify_password(self, password:str): # Corrected method name
        return bcrypt.verify(password, self.hashed_password)



class Project(Base):
    __tablename__  = 'project'

    id = Column(Integer, primary_key = True, index = True)
    name = Column(String, index = True)
    description = Column(String, nullable = True)

    employees = relationship('Employee', secondary = 'employee_project_mapping', back_populates = 'projects')

#create a model named Employee to map for our employees table in database
class Employee(Base):

    __tablename__ = 'employees'

    id = Column(Integer, primary_key = True, index = True)
    name = Column(String, index = True)
    email = Column(String, index = True, unique = True)
    is_active = Column(Boolean, default = True)
    user_id = Column(Integer, ForeignKey('users.id')) # Added foreign key for User relationship

    user = relationship('User', back_populates = 'employees') # Define relationship to User
    projects = relationship('Project', secondary = 'employee_project_mapping', back_populates ='employees')

#Many to many relationship mapping
employee_project_mapping = Table(
    'employee_project_mapping',
    Base.metadata,
    Column('employee_id', Integer, ForeignKey('employees.id'), primary_key = True),
    Column('project_id', Integer, ForeignKey('project.id'), primary_key = True),
)

================
File: schemas.py
================
from pydantic import BaseModel
from typing import List, Optional

#user section
class UserBase(BaseModel):
    username: str

class UserCreate(UserBase):
    password: str # Added password field for user creation

class User(UserBase):
    id: int
    is_active: bool
    is_superuser: bool

    class Config:
        orm_mode = True

# Employee section
class EmployeeBase(BaseModel):
    name: str
    email: str

class EmployeeCreate(EmployeeBase):
    user: UserCreate # Expect nested UserCreate for creating a user along with employee

class EmployeeUpdate(EmployeeBase):
    is_active: Optional[bool] = None

class Employee(EmployeeBase):
    id: int
    is_active: bool
    projects: List["Project"] = []
    user: Optional[User] = None # Added user relationship

    class Config:
        orm_mode = True

# Projects section
class ProjectBase(BaseModel):
    name: str
    description: Optional[str] = None

class ProjectCreate(ProjectBase):
    pass

class ProjectUpdate(ProjectBase):
    pass

class Project(ProjectBase):
    id: int
    employees: List["Employee"] = [] # Added forward reference quotes

    class Config:
        orm_mode = True

# Call model_rebuild() after defining all models with forward references
Employee.model_rebuild()
Project.model_rebuild()
User.model_rebuild()
